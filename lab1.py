# -*- coding: utf-8 -*-
"""Lab1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11mKbKnwTwlNt3_CqurMNXeEJO776sxwy
"""

import numpy as np
list1=[1.0,2.0,3.0,4.0,5.0]
npy_array=np.array(list1, dtype=np.float64)
#convert list to array(or something like matrix)
npy_array.ndim # get dimension of array
a=np.array([[1,2,3],[4,5,6],[7,8,9]], dtype=np.float64)
np.array # like creating matrix
a.ndim
a.shape
a.size # total elem in an array
a.itemsize # each elem's size(in bytes)
a.dtype.name # get elem data type name
type(a) # <class 'ndarray'> ndim array
np.indices((3,5)) # get index matrix for each elme in 3x5 matrix

np.eye(4) # get eye matrix
np.identity(3) # like eye function
z = np.zeros((3,4), dtype=np.int)
z = np.ones((3,4), dtype=np.float64)
z=np.random.random(())
z=np.random.uniform(-3, 5, (5,6))
# get 5x6 matrix with random # from -3 to 5 for each elem
z

x=np.linspace(-10,10,201)
x1=np.arange(-10.0, 10.0, 0.1)
sine=np.sin(x)
import matplotlib.pyplot as plt
plt.plot(x,sine)
plt.show()
quad1=x**2 + 2.0*x +5.0
plt.plot(x,quad1)
plt.show()
def norm_func(x,mean,var):
 return 1.0/(var*(2*np.pi)**0.5) * np.exp(-1/2*((x-mean)/var)**2)
x=np.arange(-5,5.01,0.05)
pdf1=norm_func(x,0,0.2**0.5)
pdf2=norm_func(x,0,1.0**0.5)
pdf3=norm_func(x,0,5.0**0.5)
pdf4=norm_func(x,-2.0,0.5**0.5)
plt.plot(x,pdf1,color='blue', label="mean={} var^2={}".format(0,0.2))
plt.plot(x,pdf2,color='red', label="mean={} var^2={}".format(0,1.0))
plt.plot(x,pdf3,color='yellow', label="mean={} var^2={}".format(0,5.0))
plt.plot(x,pdf4,color='green', label="mean={} var^2={}".format(-2.0,0.5))
plt.legend()
plt.show()

x=np.linspace(-4,4,9)
y=np.linspace(-5,5,11)
xx,yy=np.meshgrid(x,y) # create x, y grid matrix
xx.shape
yy.shape
ellipse = xx**2 + 4*yy**4 #
plt.contourf(xx,yy,ellipse, cmap='jet') # generate contour line
# 'jet': Red for big value; Blue for small

plt.colorbar() # create color bar at the side
plt.show()
random_data=np.random.random((11,9))
plt.contourf(xx,yy,random_data, cmap='jet') # generate contour line
# jet - color seq:blue-cyan-yello-red
plt.colorbar() # create color bar at the side
plt.show()
xx1,yy1=np.meshgrid(x,y, indexing='ij')
# xx1 is transpose xx; yy1 is transpose yy
np.all(xx == xx1.T) # xx1.T - transpose matrix
True # if all elem in expression are the same return np.all(yy ==yy1.T)
True

np.all([1,2] == [1,3])
False

xx,yy=np.meshgrid(x,y, sparse=True)
# sparse: change xx/yy format from multi-dim to 1 dim, but it is still mult-dim
xx
yy
xx.shape
yy.shape
ell=xx**2 + yy**2 # Verify above explanation
xm,ym=np.mgrid[-11:12:2.5, -11:12:2.5] # similar as meshgrid, but diff.
xm,ym=np.mgrid[-11:12:5j, -11:12:5j] # 5j - 5 points within the range, not a

xm.shape
ym.shape
xm,ym=np.ogrid[-11:12:5j, -11:12:5j] # similar as mgrid
xg, yg=np.broadcast_arrays(xm,ym)
# make x matrix format follow y matrix format

A=np.ones((5,3))
B=5*np.ones((5,3))
C=np.random.randint(-5,5,(3,5))
np.multiply(A,B) # elem times elem, not matrix multiplication
A/B
A+=B
A**=B
np.sqrt(A)
np.power(A,2)
np.exp(A)
np.dot(A,B.T)
a=np.array([[1, 2, 3],[1, 0, -1], [0, 1, 1]])
print(a.shape)
b=np.array([4, 5, 6])
print(b.T.shape)
c=np.dot(a,b.T)
c.shape
np.linalg.det(a) # determinant
np.linalg.inv(a) # inverse matrix
eigval, eigvec = np.linalg.eig(a)
 # C must be square
# return eigen values and eigen vectors
eigval
# each col in eigvec is each eigval's corresponding vector
eigvec

